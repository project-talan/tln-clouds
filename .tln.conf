const path = require('path');
const fs = require('fs');
const os = require('os');

const isWindows = os.platform() === 'win32';
const wrap = (v) => isWindows ? `%${v}%` : `\${${v}}`;

const buildScript = (layers, reverse, fn) => {
  const arr = layers.split(',');
  if (reverse) {
    arr.reverse();
  }
  const r = []
  if (isWindows) {
    r.push(`set cwd=${wrap('cd')}`);
  } else {
    r.push('cwd=$(pwd)');
  }
  arr.map(l => {
    const { cmds, cmd } = fn(l);
    r.push(`cd ${wrap('cwd')} && cd ${l}`);
    r.push(...cmds);
    r.push(`${cmd}`);
  });
  return r;
}

const getBackendConfig = (backend, layer, env) => {
  const cmds = [];
  let params = '';
  const name = [env.TF_VAR_project_id].concat(env.TLN_CLOUDS_STATE.split(',').map(v => {
    if (v === 'provider' ) 
      return env.TLN_COMPONENT_ID;
    else if (v === 'env' )
      return env.TF_VAR_env_id;
    else if (v === 'layer' )
      return layer;
    return null;
  }));
  const wName = name.join('-');
  const pName = name.join('/');
  if (backend) {
    cmds.push(`echo 'terraform {' > backend.tf`);
    switch (backend) {
      case 'cloud':
        cmds.push(`echo '  cloud {' >> backend.tf`);
        cmds.push(`echo '    organization = "${env.TF_VAR_org_id}"' >> backend.tf`);
        cmds.push(`echo '    workspaces { name = "${wName}" }' >> backend.tf`);
        cmds.push(`echo '  }' >> backend.tf`);
        break;
      case 'remote':
        cmds.push(`echo '  backend "remote" {' >> backend.tf`);
        cmds.push(`echo '    organization = "${env.TF_VAR_org_id}"' >> backend.tf`);
        cmds.push(`echo '    workspaces { name = "${wName}" }' >> backend.tf`);
        cmds.push(`echo '  }' >> backend.tf`);
        break;
      case 'pg':
        cmds.push(`echo '  backend "remote" {' >> backend.tf`);
        cmds.push(`echo '    conn_str = "${env.TF_VAR_backend_pg_conn_str}"' >> backend.tf`);
        cmds.push(`echo '  }' >> backend.tf`);
        break;
      case 's3':
        //terraform init -backend-config="access_key=<your access key>" -backend-config="secret_key=<your secret key>"
        cmds.push(`echo '  backend "s3" {' >> backend.tf`);
        cmds.push(`echo '    bucket = "${env.TF_VAR_backend_s3_bucket}"' >> backend.tf`);
        cmds.push(`echo '    key = "tfenvs/${pName}/terraform.tfstate"' >> backend.tf`);
        cmds.push(`echo '    dynamodb_table = "${env.TF_VAR_backend_s3_dynamodb_table}"' >> backend.tf`);
        cmds.push(`echo '    region = \\"${env.TF_VAR_backend_s3_region}"' >> backend.tf`);
        cmds.push(`echo '  }' >> backend.tf`);
        break;
    }
    cmds.push(`echo '}' >> backend.tf`);
    if (env.TLN_CLOUDS_UPGRADE) {
      params = ' -upgrade';
    }
  } else {
    params = ' -reconfigure';
    cmds.push('rm -f backend.tf');
  }
  return {cmds, params};
}

const getScript = (env, reverse) => {
  return buildScript(env.TLN_CLOUDS_LAYERS, reverse, layer => {
    const { cmds, params } = getBackendConfig(env.TLN_CLOUDS_BACKEND, layer, env);
    //
    const tCmds = [];
    const destroy = reverse?' -destroy':'';
    if (env.TLN_CLOUDS_INIT) {
      tCmds.push(`terraform init${params}`);
    }
    if (env.TLN_CLOUDS_PLAN) {
      tCmds.push(`terraform plan${destroy}`);
    }
    if (env.TLN_CLOUDS_APPLY) {
      tCmds.push(`terraform apply${destroy}${env.TLN_CLOUDS_AUTO_APPROVE?' -auto-approve':''}`);
    }
    return { cmds: cmds || [], cmd: tCmds.join(' && ')};
  });
}

module.exports = {
  options: async (tln, args) => {
    args
      .prefix('TLN_CLOUDS')
      .option('backend',      { describe: 'Use cloud based terraform backend', default: null, type: 'string' })
      .option('state',        { describe: 'Define which level store the state: provider,env,layer', default: 'provider,env,layer', type: 'string' })
      .option('init',         { describe: 'Terraform init', default: false, type: 'boolean' })
      .option('upgrade',      { describe: 'Terraform upgrade mode for init', default: false, type: 'boolean' })
      .option('plan',         { describe: 'Terraform plan execution', default: false, type: 'boolean' })
      .option('apply',        { describe: 'Terraform apply execution', default: false, type: 'boolean' })
      .option('auto-approve', { describe: 'Auto apprive apply & destroy', default: false, type: 'boolean' })
      .option('layers',       { describe: 'List of comma-separated layers application has', default: "network,managed", type: 'string' })
      .option('bastion',      { describe: 'Bastion in form user@ip', default: null, type: 'string' })
      .option('bridge-port',  { describe: 'Local port for bridge to bastion user@ip', default: '8888', type: 'string' })
    ;
  },
  env: async (tln, env) => {
    // DO - provider layer
    //env.TF_VAR_domain_tag = 'tln-sh';
    //env.TF_VAR_private_key = path.join(__dirname, 'secrets', 'tln.sh.key');
    //env.TF_VAR_certificate_chain = path.join(__dirname, 'secrets', 'tln.sh.ca-bundle');
    //env.TF_VAR_leaf_certificate = path.join(__dirname, 'secrets', 'tln.sh.crt');
  },
  dotenvs: async (tln) => ['.env'],
  inherits: async (tln) => [],
  depends: async (tln) => [],
  steps: async (tln) => [
    { id: 'construct', builder: async (tln, script) => {
        script.set(getScript(script.env, false));
      }
    },
    { id: 'deconstruct', builder: async (tln, script) => {
        script.set(getScript(script.env, true));
      }
    },
    { id: 'bridge', builder: async (tln, script) => {
        switch (script.env.TLN_COMPONENT_ID) {
          case 'aws':
            script.set([`
ssh -i ./managed/${script.env.TF_VAR_env_id}-bastion-ssh-key.pem -L8888:127.0.0.1:${script.env.TLN_CLOUDS_BRIDGE_PORT} ${script.env.TLN_CLOUDS_BASTION}
            `]);
            break;
          case 'azure':
            break;
          case 'gcp':
            break;
        }
      }
    },
    { id: 'connect', builder: async (tln, script) => {
        switch (script.env.TLN_COMPONENT_ID) {
          case 'aws':
            script.set([`
export HTTPS_PROXY=127.0.0.1:8888
tln shell
            `]);
            break;
          case 'azure':
            break;
          case 'gcp':
            break;
        }
      }
    },
  ],
  components: async (tln) => []
}